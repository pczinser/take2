-- Attached to world_manager game object
local world = require("game.scripts.module.world.world")
local bus = require("game.scripts.sim_bus")
local cmd = require("game.scripts.command_queue")

local world_manager = {
    loaded_chunks = {},  -- Track which chunks are loaded
    observer_config = nil,
    initialized = false  -- Track if we have an observer and can start loading chunks
}

function init(self)
    print("World manager starting - ensuring observer...")
    print("World manager game object ID:", go.get_id())
    -- Ensure a default observer exists so chunk logic can begin before player binds
    cmd.set_observer_position(0, 0, 0, 0)
    
    -- Subscribe to bus for ticks with our URL
    print("World manager subscribing to sim_bus...")
    bus.subscribe(msg.url())
    print("World manager subscribed to sim_bus")
end

function update(self, dt)
    -- No per-frame work; reacts on ticks via bus
end

function on_message(self, message_id, message, sender)
    if message_id == hash("bus_tick") then
        print("World manager received bus_tick!")
        -- Check if we have an observer yet
        if not world_manager.initialized then
            world_manager.observer_config = world.get_observer_config()
            if world_manager.observer_config then
                print("World manager initialized - Hot radius: " .. world_manager.observer_config.hot_chunk_radius .. " chunks")
                world_manager.initialized = true
            else
                -- Still waiting for observer
                print("World manager still waiting for observer...")
                return
            end
        end
        load_active_chunks()
    elseif message_id == hash("bus_spawn") then
        -- Optional: handle immediate spawn events
    elseif message_id == hash("bus_despawn") then
        -- Optional: handle immediate despawn events
    elseif message_id == hash("bus_event") then
        -- Optional: handle immediate events
    end
end

-- Only spawn visual chunks for hot chunks
function load_active_chunks()
    local visual_chunks = world.get_visual_chunks(0)  -- Only hot chunks
    print("Visual chunks count:", #visual_chunks)
    
    -- Create a set of chunks that should be loaded
    local should_load_chunks = {}
    for _, chunk_data in ipairs(visual_chunks) do
        local chunk_key = string.format("%d_%d_%d", chunk_data.floor_z, chunk_data.chunk_x, chunk_data.chunk_y)
        should_load_chunks[chunk_key] = true
    end
    
    -- Unload chunks that are no longer needed
    for chunk_key, chunk_data in pairs(world_manager.loaded_chunks) do
        if not should_load_chunks[chunk_key] then
            unload_chunk(chunk_key)
        end
    end
    
    -- Load new chunks that aren't already loaded
    for _, chunk_data in ipairs(visual_chunks) do
        local chunk_key = string.format("%d_%d_%d", chunk_data.floor_z, chunk_data.chunk_x, chunk_data.chunk_y)
        
        if not world_manager.loaded_chunks[chunk_key] then
            print("Attempting to create chunk at:", chunk_data.floor_z, chunk_data.chunk_x, chunk_data.chunk_y)
            print("Current game object ID:", go.get_id())
            
            -- Spawn chunk collection using relative addressing (now in correct context)
            local chunk_ids = collectionfactory.create("#chunk_factory")
            
            -- Find the tilemap game object in the spawned collection
            local tilemap_id = chunk_ids[hash("/tilemap")] or chunk_ids[hash("tilemap")]
            
            if tilemap_id then
                -- Extract collection root ID from tilemap path
                local collection_root_id = get_collection_root_id(tilemap_id)
                
                if collection_root_id then
                    -- Send chunk data via message to the tilemap
                    msg.post(tilemap_id, "set_chunk_data", {
                        floor_z = chunk_data.floor_z,
                        chunk_x = chunk_data.chunk_x,
                        chunk_y = chunk_data.chunk_y
                    })
                    
                    world_manager.loaded_chunks[chunk_key] = {
                        collection_ids = chunk_ids,
                        tilemap_id = tilemap_id,
                        collection_root_id = collection_root_id
                    }
                    print(string.format("Loaded chunk z=%d cx=%d cy=%d", chunk_data.floor_z, chunk_data.chunk_x, chunk_data.chunk_y))
                else
                    print("ERROR: Could not extract collection root ID from tilemap:", tilemap_id)
                end
            else
                print("ERROR: Could not find tilemap in spawned chunk collection; keys=")
                for k, v in pairs(chunk_ids or {}) do
                    print("  key:", k, " val:", v)
                end
            end
        end
    end
end

function unload_chunk(chunk_key)
    local chunk_data = world_manager.loaded_chunks[chunk_key]
    if chunk_data then
        -- Unload the collection factory resources (note: does not delete existing instances)
        collectionfactory.unload("#chunk_factory")
        
        -- Clean up our tracking
        world_manager.loaded_chunks[chunk_key] = nil
    else
        -- Clean up the invalid entry
        world_manager.loaded_chunks[chunk_key] = nil
    end
end

-- Helper function to get collection root ID from tilemap ID
function get_collection_root_id(tilemap_id)
    local tilemap_path = tostring(tilemap_id)
    -- Extract collection name from path like "/collection0/tilemap"
    local collection_name = string.match(tilemap_path, "/([^/]+)/")
    if collection_name then
        return hash("/" .. collection_name)
    end
    return nil
end

function final(self)
    bus.unsubscribe(msg.url())
end

function fixed_update(self, dt)
    -- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
    -- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
    -- Physics section of game.project
    -- Add update code here
    -- Learn more: https://defold.com/manuals/script/
    -- Remove this function if not needed
end

function on_input(self, action_id, action)
    -- Add input-handling code here. The game object this script is attached to
    -- must have acquired input focus:
    --
    --    msg.post(".", "acquire_input_focus")
    --
    -- All mapped input bindings will be received. Mouse and touch input will
    -- be received regardless of where on the screen it happened.
    -- Learn more: https://defold.com/manuals/input/
    -- Remove this function if not needed
end

function on_reload(self)
    -- Add reload-handling code here
    -- Learn more: https://defold.com/manuals/hot-reload/
    -- Remove this function if not needed
end
