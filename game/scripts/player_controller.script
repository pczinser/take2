-- This is a Defold script file with proper lifecycle functions

-- Import the command queue module
local cmd = require("game.scripts.command_queue")

-- Convert world coordinates to grid coordinates (Defold system)
local function world_to_grid(world_x, world_y)
	return world_x / 64.0, world_y / 64.0  -- No flipping needed
end

-- Convert grid coordinates to world coordinates (Defold system)  
local function grid_to_world(grid_x, grid_y)
	return grid_x * 64.0, grid_y * 64.0  -- No flipping needed
end



-- Add this function to display player stats
function show_player_stats(self)
	local player = sim.get_entity(self.player_id)
	if not player then
		print("ERROR: Player entity not found!")
		return
	end
	
	print("=== PLAYER STATS ===")
	print(string.format("Position: (%.1f, %.1f)", player.grid_x, player.grid_y))
	print(string.format("Floor: %d", player.floor_z))
	print(string.format("Chunk: (%d, %d)", player.chunk_x, player.chunk_y))
	print(string.format("Entity ID: %d", player.id))
	print(string.format("Move Speed: %.1f", player.move_speed or 100.0))
	
	-- Show inventory contents using new component-based system
	print("=== INVENTORY ===")
	
	-- Get total number of slots
	local total_slots = sim.inventory_get_slot_count(self.player_id)
	print(string.format("Total slots: %d", total_slots))
	
	local used_slots = 0
	local total_items = 0
	local input_slots = 0
	local output_slots = 0
	
	-- Check all slots
	for slot_index = 0, total_slots - 1 do
		local item_type = sim.inventory_get_slot_item(self.player_id, slot_index)
		local quantity = sim.inventory_get_slot_quantity(self.player_id, slot_index)
		local is_output = sim.inventory_is_slot_output(self.player_id, slot_index)
		
		if is_output then
			output_slots = output_slots + 1
		else
			input_slots = input_slots + 1
		end
		
		if item_type ~= 0 then  -- ITEM_NONE = 0
			used_slots = used_slots + 1
			total_items = total_items + quantity
			
			local item_name = get_item_name(item_type)
			local slot_type = is_output and "Output" or "Input"
			print(string.format("  %s slot %d: %s x%d", slot_type, slot_index, item_name, quantity))
		end
	end
	
	print(string.format("Inventory: %d/%d slots used (%d input, %d output), %d total items", 
				   used_slots, total_slots, input_slots, output_slots, total_items))
	
	print("===================")
end

-- Helper function to convert item type enum to name
function get_item_name(item_type)
	local item_names = {
		[0] = "None",
		[1] = "Stone",
		[2] = "Iron", 
		[3] = "Wood",
		[4] = "Herbs",
		[5] = "Mushrooms",
		[6] = "Crystal",
		[7] = "Cut Stone"
	}
	return item_names[item_type] or "Unknown"
end

-- Add this function to test inventory functionality
function test_inventory(self)
	print("=== TESTING INVENTORY ===")
	
	-- Try to add some items to player inventory using commands
	cmd.add_item_to_inventory(self.player_id, 0, 1, 5)  -- 5 stone to slot 0
	cmd.add_item_to_inventory(self.player_id, 1, 2, 3)  -- 3 iron to slot 1
	cmd.add_item_to_inventory(self.player_id, 2, 3, 10) -- 10 wood to slot 2
	
	print("Added items via commands (success will be determined by C++ processing)")
	
	-- Show updated stats
	show_player_stats(self)
end

function init(self)
	--msg.post(".", "acquire_input_focus")
	
	-- Initialize movement variables
	self.move_dx = 0
	self.move_dy = 0
	
	-- Initialize floor tracking
	self.current_floor = 0
	
	-- Wait a frame for entities to be created, then find them
	timer.delay(0.1, false, function()
		-- Try to get entity IDs directly from the simulation by prototype name
		local players = sim.get_entities_by_prototype("player")
		
		if #players > 0 then
			self.player_id = players[1]
			
			print("Found entities:")
			print("  Player: " .. self.player_id)
			
			-- Add starter items to player inventory (ONCE)
			cmd.add_item_to_inventory(self.player_id, 0, 1, 5)  -- 5 stone to slot 0
			cmd.add_item_to_inventory(self.player_id, 1, 2, 3)  -- 3 iron to slot 1
			cmd.add_item_to_inventory(self.player_id, 2, 3, 10) -- 10 wood to slot 2
			
			-- Bind observer to follow the player entity (creates default if missing)
			cmd.observer_follow_entity(self.player_id)
			
			print("=== PLAYER CONTROLLER READY ===")
		else
			print("ERROR: Could not find player!")
		end
	end)
	
	print("=== PLAYER CONTROLLER INITIALIZED ===")
end

function update(self, dt)
	-- Defer until player_id is available
	if not self.player_id then return end
	
	-- Simple grid-based movement using commands
	if self.move_dx ~= 0 or self.move_dy ~= 0 then
		-- Calculate grid movement (slower, more controlled)
		local move_speed = 100.0  -- Default movement speed
		local grid_dx = (self.move_dx * move_speed * dt) / 64.0
		local grid_dy = (self.move_dy * move_speed * dt) / 64.0
		
		-- Move entity using command
		cmd.move_entity(self.player_id, grid_dx, grid_dy)
	end
	
	-- Update Defold position from simulation (this will come from snapshots)
	-- For now, we'll need to get position from simulation
	local transform = sim.get_entity_transform(self.player_id)
	if transform then
		local world_x, world_y = grid_to_world(transform.grid_x, transform.grid_y)
		
		-- Only update if position changed
		if world_x ~= self.last_x or world_y ~= self.last_y then
			go.set_position(vmath.vector3(world_x, world_y, 0), self.id)
			self.last_x = world_x
			self.last_y = world_y
		end
	end
	
	-- Update simulation state for animation system
	if self.move_dx ~= 0 or self.move_dy ~= 0 then
		-- Set movement state
		cmd.set_entity_state_flag(self.player_id, "moving", "true")
		
		-- Set facing direction
		if self.move_dx > 0 then
			cmd.set_entity_state_flag(self.player_id, "facing", "east")
		elseif self.move_dx < 0 then
			cmd.set_entity_state_flag(self.player_id, "facing", "west")
		elseif self.move_dy > 0 then
			cmd.set_entity_state_flag(self.player_id, "facing", "north")
		elseif self.move_dy < 0 then
			cmd.set_entity_state_flag(self.player_id, "facing", "south")
		end
	else
		-- Not moving
		cmd.set_entity_state_flag(self.player_id, "moving", "false")
	end
end

function on_message(self, message_id, message, sender)
	-- Handle messages from other game objects
end

function on_input(self, action_id, action)
	-- Handle input events
	if action_id == hash("key_w") then
		if action.pressed then
			self.move_dy = self.move_dy + 1  -- UP (positive Y in Defold)
		elseif action.released then
			self.move_dy = self.move_dy - 1
		end
	elseif action_id == hash("key_s") then
		if action.pressed then
			self.move_dy = self.move_dy - 1  -- DOWN (negative Y in Defold)
		elseif action.released then
			self.move_dy = self.move_dy + 1
		end
	elseif action_id == hash("key_a") then
		if action.pressed then
			self.move_dx = self.move_dx - 1  -- LEFT (negative X)
		elseif action.released then
			self.move_dx = self.move_dx + 1
		end
	elseif action_id == hash("key_d") then
		if action.pressed then
			self.move_dx = self.move_dx + 1  -- RIGHT (positive X)
		elseif action.released then
			self.move_dx = self.move_dx - 1
		end
	elseif action_id == hash("key_p") and action.pressed then
		-- Debug output
		local player = sim.get_entity(self.player_id)
		if player then
			local world_x, world_y = grid_to_world(player.grid_x, player.grid_y)  -- CHANGED: Convert grid to world
			print(string.format("Player at world: (%.1f, %.1f) grid: (%.1f, %.1f) floor: %d", 
					   world_x, world_y, player.grid_x, player.grid_y, player.floor_z))
		end
	elseif action_id == hash("key_tab") and action.pressed then
		show_player_stats(self)
	end

	-- Floor switching
	if action_id == hash("wheel_up") and action.pressed then
		local new_floor = self.current_floor + 1
		-- Note: set_current_floor might need to be a command too
		self.current_floor = new_floor
		
		-- Actually move the player to the new floor
		cmd.set_entity_floor(self.player_id, new_floor)
		print("Moved player to floor " .. new_floor)
		
		-- List entities on the new floor (this might need to be a command too)
		local floor_entities = sim.get_entities_on_floor(new_floor)
		print("Entities on floor " .. new_floor .. ": " .. #floor_entities)
		for i, entity_id in ipairs(floor_entities) do
			local entity = sim.get_entity(entity_id)
			if entity then
				print("  Entity " .. entity_id .. " at (" .. entity.grid_x .. ", " .. entity.grid_y .. ")")
			end
		end
	elseif action_id == hash("wheel_down") and action.pressed then
		local new_floor = self.current_floor - 1
		-- Note: set_current_floor might need to be a command too
		self.current_floor = new_floor
		
		-- Actually move the player to the new floor
		cmd.set_entity_floor(self.player_id, new_floor)
		print("Moved player to floor " .. new_floor)
		
		-- List entities on the new floor (this might need to be a command too)
		local floor_entities = sim.get_entities_on_floor(new_floor)
		print("Entities on floor " .. new_floor .. ": " .. #floor_entities)
		for i, entity_id in ipairs(floor_entities) do
			local entity = sim.get_entity(entity_id)
			if entity then
				print("  Entity " .. entity_id .. " at (" .. entity.grid_x .. ", " .. entity.grid_y .. ")")
			end
		end
	end
end

function final(self)
	-- Cleanup when the game object is destroyed
end
