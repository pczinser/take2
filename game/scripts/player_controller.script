-- This is a Defold script file with proper lifecycle functions

-- Convert world coordinates to grid coordinates (Defold system)
local function world_to_grid(world_x, world_y)
    return world_x / 64.0, world_y / 64.0  -- No flipping needed
end

-- Convert grid coordinates to world coordinates (Defold system)  
local function grid_to_world(grid_x, grid_y)
    return grid_x * 64.0, grid_y * 64.0  -- No flipping needed
end

-- Define test_chunk_state as a local function
local function test_chunk_state(player_id, building_id)
    print("=== CHUNK STATE TEST ===")
    
    -- Get player position
    local player = sim.get_entity(player_id)
    local building = sim.get_entity(building_id)
    
    if player and building then
        -- Debug: print all fields in the player entity
        print("Player entity fields:")
        for key, value in pairs(player) do
            print("  " .. key .. " = " .. tostring(value))
        end
        
        print("Building entity fields:")
        for key, value in pairs(building) do
            print("  " .. key .. " = " .. tostring(value))
        end
        
        -- Only print chunk info if the fields exist
        if player.chunk_x and player.chunk_y then
            print(string.format("Player at grid (%.1f, %.1f) chunk (%d, %d) floor %d", 
                               player.grid_x, player.grid_y, player.chunk_x, player.chunk_y, player.floor_z))
        else
            print(string.format("Player at grid (%.1f, %.1f) chunk (unknown)", 
                               player.grid_x, player.grid_y))
        end
        
        if building.chunk_x and building.chunk_y then
            print(string.format("Building at grid (%.1f, %.1f) chunk (%d, %d) floor %d", 
                               building.grid_x, building.grid_y, building.chunk_x, building.chunk_y, building.floor_z))
        else
            print(string.format("Building at grid (%.1f, %.1f) chunk (unknown)", 
                               building.grid_x, building.grid_y))
        end
        
        -- Check entities in building's chunk (if we have chunk coordinates)
        if building.chunk_x and building.chunk_y then
            local building_chunk_entities = sim.get_entities_in_chunk(building.floor_z, building.chunk_x, building.chunk_y)
            print(string.format("Entities in building chunk (%d, %d) floor %d: %d", 
                               building.chunk_x, building.chunk_y, building.floor_z, #building_chunk_entities))
        end
        
        -- Check entities in player's chunk (if we have chunk coordinates)
        if player.chunk_x and player.chunk_y then
            local player_chunk_entities = sim.get_entities_in_chunk(player.floor_z, player.chunk_x, player.chunk_y)
            print(string.format("Entities in player chunk (%d, %d) floor %d: %d", 
                               player.chunk_x, player.chunk_y, player.floor_z, #player_chunk_entities))
        end
        
        -- Check entities near building
        local nearby_entities = sim.get_entities_in_radius(building.grid_x, building.grid_y, 100)  -- CHANGED: grid coordinates
        print(string.format("Entities within 100 grid units of building: %d", #nearby_entities))
        
        -- Check if building is still there
        local building_still_exists = sim.get_entity(building_id)
        if building_still_exists then
            print("Building still exists in simulation")
        else
            print("ERROR: Building disappeared!")
        end
    end
    
    print("=======================")
end

-- Add this function to display player stats
function show_player_stats(self)
    local player = sim.get_entity(self.player_id)
    if not player then
        print("ERROR: Player entity not found!")
        return
    end
    
    print("=== PLAYER STATS ===")
    print(string.format("Position: (%.1f, %.1f)", player.grid_x, player.grid_y))
    print(string.format("Floor: %d", player.floor_z))
    print(string.format("Chunk: (%d, %d)", player.chunk_x, player.chunk_y))
    print(string.format("Entity ID: %d", player.id))
    
    -- Show inventory contents if player has inventories
    if player.inventory_ids and #player.inventory_ids > 0 then
        print("=== INVENTORIES ===")
        for i, inventory_id in ipairs(player.inventory_ids) do
            print(string.format("Inventory %d (ID: %d):", i, inventory_id))
            
            -- Get inventory capacity and free space
            local capacity = sim.inventory_get_capacity(inventory_id)
            local free_space = sim.inventory_get_free_space(inventory_id)
            local used_space = capacity - free_space
            
            print(string.format("  Capacity: %d/%d (%.1f%% full)", used_space, capacity, (used_space/capacity)*100))
            
            -- Check for each item type
            local item_types = {"stone", "iron", "wood", "herbs", "mushrooms", "crystal"}
            local item_enum = {0, 1, 2, 3, 4, 5} -- ITEM_STONE = 0, etc.
            
            for j, item_name in ipairs(item_types) do
                local count = sim.inventory_get_item_count(inventory_id, item_enum[j])
                if count > 0 then
                    print(string.format("    %s: %d", item_name, count))
                end
            end
        end
    else
        print("No inventories found")
    end
    
    print("===================")
end

function init(self)
    msg.post(".", "acquire_input_focus")
    
    -- Initialize movement variables
    self.move_dx = 0
    self.move_dy = 0
    
    -- Initialize floor tracking
    self.current_floor = 0
    
    -- Register entity prototypes using new inventory system
    local entity_prototypes = {
        player = {
            components = {
                metadata = {
                    display_name = "Player",
                    category = "player"
                },
                transform = {
                    move_speed = 100.0
                },
                health = {
                    amount = 100
                },
                inventory = {
                    slots = {
                        -- 50 general slots for player
                        { is_output = false, whitelist = {} },  -- Slot 1
                        { is_output = false, whitelist = {} },  -- Slot 2
                        -- ... repeat for 50 slots
                    }
                }
            }
        },
        
        crafting_building = {
            components = {
                metadata = {
                    display_name = "Crafting Building",
                    category = "building"
                },
                transform = {
                    move_speed = 0.0
                },
                building = {
                    width = 1,
                    height = 1,
                    type = "crafting"
                },
                production = {
                    rate = 10.0
                },
                health = {
                    amount = 100
                },
                inventory = {
                    slots = {
                        { is_output = false, whitelist = {0, 2} },  -- Input slot (stone, wood)
                        { is_output = false, whitelist = {1} },      -- Input slot (iron)
                        { is_output = true, whitelist = {7} }        -- Output slot (cut stone)
                    }
                }
            }
        }
    }
    
    sim.register_entity_prototypes(entity_prototypes)
    
    -- Create the player entity from prototype
    self.player_id = sim.create_entity("player", 0, 0, 0)
    print("Created player with ID: " .. self.player_id)
    
    -- Create a crafting building from prototype
    self.crafting_id = sim.create_entity("crafting_building", 1, 1, 0)
    print("Created crafting building with ID: " .. self.crafting_id)
    
    -- Create observer for the player
    self.observer_id = sim.set_observer(0, 0, 0, 10, 5, 0, 1)
    
    print("=== NEW INVENTORY SYSTEM INITIALIZED ===")
end

function update(self, dt)
    -- Simple grid-based movement using transform component
    if self.move_dx ~= 0 or self.move_dy ~= 0 then
        local transform = sim.get_entity_transform(self.player_id)
        if transform then
            -- Get movement speed from transform component
            local move_speed = transform.movement_speed or 100.0
            
            -- Calculate grid movement (slower, more controlled)
            local grid_dx = (self.move_dx * move_speed * dt) / 64.0
            local grid_dy = (self.move_dy * move_speed * dt) / 64.0
            
            -- Move entity directly (no velocity system)
            sim.move_entity(self.player_id, grid_dx, grid_dy)
        end
    end
    
    -- Update Defold position from simulation
    local transform = sim.get_entity_transform(self.player_id)
    if transform then
        local world_x, world_y = grid_to_world(transform.grid_x, transform.grid_y)
        
        -- Only update if position changed
        if world_x ~= self.last_x or world_y ~= self.last_y then
            go.set_position(vmath.vector3(world_x, world_y, 0), self.id)
            self.last_x = world_x
            self.last_y = world_y
            
            -- Update observer
            sim.move_observer(self.observer_id, 0, transform.grid_x, transform.grid_y)
        end
    end
end

function on_message(self, message_id, message, sender)
    -- Handle messages from other game objects
end

function on_input(self, action_id, action)
    -- Handle input events
    if action_id == hash("key_w") then
        if action.pressed then
            self.move_dy = self.move_dy + 1  -- UP (positive Y in Defold)
        elseif action.released then
            self.move_dy = self.move_dy - 1
        end
    elseif action_id == hash("key_s") then
        if action.pressed then
            self.move_dy = self.move_dy - 1  -- DOWN (negative Y in Defold)
        elseif action.released then
            self.move_dy = self.move_dy + 1
        end
    elseif action_id == hash("key_a") then
        if action.pressed then
            self.move_dx = self.move_dx - 1  -- LEFT (negative X)
        elseif action.released then
            self.move_dx = self.move_dx + 1
        end
    elseif action_id == hash("key_d") then
        if action.pressed then
            self.move_dx = self.move_dx + 1  -- RIGHT (positive X)
        elseif action.released then
            self.move_dx = self.move_dx - 1
        end
    elseif action_id == hash("key_p") and action.pressed then
        -- Debug output
        local player = sim.get_entity(self.player_id)
        if player then
            local world_x, world_y = grid_to_world(player.grid_x, player.grid_y)  -- CHANGED: Convert grid to world
            print(string.format("Player at world: (%.1f, %.1f) grid: (%.1f, %.1f) floor: %d", 
                               world_x, world_y, player.grid_x, player.grid_y, player.floor_z))
        end
    elseif action_id == hash("key_t") and action.pressed then
        -- Test chunk state
        test_chunk_state(self.player_id, self.crafting_id)
    elseif action_id == hash("key_r") and action.pressed then
        -- Teleport player back to building (grid coordinates AND floor)
        local building = sim.get_entity(self.crafting_id)
        if building then
            sim.set_entity_position(self.player_id, building.grid_x, building.grid_y)
            sim.set_entity_floor(self.player_id, building.floor_z)
            self.current_floor = building.floor_z
            sim.set_current_floor(building.floor_z)
            print(string.format("Teleported player to building at grid (%.1f, %.1f) on floor %d", 
                               building.grid_x, building.grid_y, building.floor_z))
        else
            print("ERROR: Building not found!")
        end
    elseif action_id == hash("key_tab") and action.pressed then
        show_player_stats(self)
    end

    -- Floor switching
    if action_id == hash("wheel_up") and action.pressed then
        local new_floor = self.current_floor + 1
        sim.set_current_floor(new_floor)
        self.current_floor = new_floor
        
        -- Actually move the player to the new floor
        sim.set_entity_floor(self.player_id, new_floor)
        print("Moved player to floor " .. new_floor)
        
        -- List entities on the new floor
        local floor_entities = sim.get_entities_on_floor(new_floor)
        print("Entities on floor " .. new_floor .. ": " .. #floor_entities)
        for i, entity_id in ipairs(floor_entities) do
            local entity = sim.get_entity(entity_id)
            if entity then
                print("  Entity " .. entity_id .. " at (" .. entity.grid_x .. ", " .. entity.grid_y .. ")")
            end
        end
    elseif action_id == hash("wheel_down") and action.pressed then
        local new_floor = self.current_floor - 1
        sim.set_current_floor(new_floor)
        self.current_floor = new_floor
        
        -- Actually move the player to the new floor
        sim.set_entity_floor(self.player_id, new_floor)
        print("Moved player to floor " .. new_floor)
        
        -- List entities on the new floor
        local floor_entities = sim.get_entities_on_floor(new_floor)
        print("Entities on floor " .. new_floor .. ": " .. #floor_entities)
        for i, entity_id in ipairs(floor_entities) do
            local entity = sim.get_entity(entity_id)
            if entity then
                print("  Entity " .. entity_id .. " at (" .. entity.grid_x .. ", " .. entity.grid_y .. ")")
            end
        end
    end
end

function final(self)
    -- Cleanup when the game object is destroyed
end
