local bus = require("game.scripts.sim_bus")
local sim = require("game.scripts.sim")
local visual_manager = require("game.scripts.visual_manager")

-- This script owns lifecycle and delegates logic to the visual_manager module

function init(self)
    -- Ensure module is initialized once
    visual_manager.init()
    bus.subscribe(msg.url())
end

function on_message(self, message_id, message, sender)
    if message_id == hash("bus_tick") then
        -- Get snapshot data from the sim_bus (which already read it)
        local prev, curr, alpha, tick = bus.get_snapshots()
        
        if not curr then return end
        
        local streams = {
            curr = {
                id = buffer.get_stream(curr, hash("id")),
                x = buffer.get_stream(curr, hash("x")),
                y = buffer.get_stream(curr, hash("y")),
                z = buffer.get_stream(curr, hash("z")),
                vx = buffer.get_stream(curr, hash("vx")),
                vy = buffer.get_stream(curr, hash("vy")),
                ang = buffer.get_stream(curr, hash("ang")),
                flags = buffer.get_stream(curr, hash("flags")),
            }
        }

        -- Boot diagnostics: print stream lengths and first few values once
        self._vm_debug_once = self._vm_debug_once or false
        if not self._vm_debug_once then
            local function safe_index(arr, idx)
                if not arr then return 0 end
                local n = #arr
                if n < 1 then return 0 end
                if idx > n then idx = n end
                return arr[idx] or 0
            end
            local id1 = safe_index(streams.curr.id, 1)
            local id2 = safe_index(streams.curr.id, 2)
            local id3 = safe_index(streams.curr.id, 3)
            local x1 = safe_index(streams.curr.x, 1)
            local x2 = safe_index(streams.curr.x, 2)
            local x3 = safe_index(streams.curr.x, 3)
            local y1 = safe_index(streams.curr.y, 1)
            local y2 = safe_index(streams.curr.y, 2)
            local y3 = safe_index(streams.curr.y, 3)
            local z1 = safe_index(streams.curr.z, 1)
            local z2 = safe_index(streams.curr.z, 2)
            local z3 = safe_index(streams.curr.z, 3)
            print("VM DEBUG: lens id/x/y/z =", streams.curr.id and #streams.curr.id or 0, streams.curr.x and #streams.curr.x or 0, streams.curr.y and #streams.curr.y or 0, streams.curr.z and #streams.curr.z or 0)
            print("VM DEBUG: head id=", id1, id2, id3, " x=", x1, x2, x3, " y=", y1, y2, y3, " z=", z1, z2, z3)
            self._vm_debug_once = true
        end

        if prev then
            streams.prev = {
                id = buffer.get_stream(prev, hash("id")),
                x = buffer.get_stream(prev, hash("x")),
                y = buffer.get_stream(prev, hash("y")),
                z = buffer.get_stream(prev, hash("z")),
                vx = buffer.get_stream(prev, hash("vx")),
                vy = buffer.get_stream(prev, hash("vy")),
                ang = buffer.get_stream(prev, hash("ang")),
                flags = buffer.get_stream(prev, hash("flags")),
            }
        end

        -- Delegate to the module to update visuals
        if visual_manager.on_snapshot_tick then
            visual_manager.on_snapshot_tick(streams, alpha, sim)
        end
    elseif message_id == hash("bus_spawn") then
        -- Optional immediate handling (module may ignore)
        if visual_manager.on_spawn then visual_manager.on_spawn(message) end
    elseif message_id == hash("bus_despawn") then
        if visual_manager.on_despawn then visual_manager.on_despawn(message) end
    elseif message_id == hash("bus_event") then
        if visual_manager.on_event then visual_manager.on_event(message) end
    end
end

function final(self)
    bus.unsubscribe(msg.url())
    if visual_manager.cleanup then visual_manager.cleanup() end
end


